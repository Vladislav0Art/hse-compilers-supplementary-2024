-- Parser
import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
   failure("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
   case atr of
     Ref  -> error("reference expected", loc)
   | Void -> Ignore(v)
   | _    -> v
   esac
}

fun assertVoid (atr, v, loc) {
   case atr of
     Void -> v
   | Val  -> error("value expected", loc)
   | _    -> error("reference expected", loc)
   esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
   syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
    fun (a) {assertValue(a, Binop(op, l(Val), r(Val)), loc)}
  }]
}

var ifContinuationStmt = memo $ eta syntax (
  e=exp kThen s=exp                              { fun(attr) { If(e(Val), s(attr), Skip) } } |
  e=exp kThen s1=exp kElse s2=exp                { fun(attr) { If(e(Val), s1(attr), s2(attr)) } }  |
  e=exp kThen s1=exp kElif s2=ifContinuationStmt { fun(attr) { If(e(Val), s1(attr), s2(attr)) } }
);

var primary = memo $ eta syntax (
  -- decimal constant
  loc=pos x=decimal {fun (a) {assertValue(a, Const(stringInt(x)), loc)}} |

  -- identifier
  x=lident {
    fun (a) {
        case a of
          Ref  -> Ref(x)
        | Void -> Ignore(Var(x))
        | _    -> Var(x)
        esac
    }
  } |
  -- brackets
  inbr[s("("), exp, s(")")] |
  -- Assn
  -- x=lident s[":="] e=exp {Assn (x, e)}

  -- kSkip {Skip}
  loc=pos kSkip { fun(attr) { assertVoid(attr, Skip, loc) } } |

  -- kRead x=inbr[s("("), lident, s(")")] { Read (x) }
  loc=pos kRead x=inbr[s("("), lident, s(")")] { fun(attr) { assertVoid(attr, Read(x), loc) } } |

  -- kWrite expr=inbr[s("("), exp, s(")")] { Write (expr) }
  loc=pos kWrite myExpr=inbr[s("("), exp, s(")")] { fun(attr) { assertVoid(attr, Write(myExpr(Val)), loc) } } |

  -- control flow statements:

  -- if E then S ([skip | elif | else]*) fi
  -- kIf s=ifContinuationStmt kFi { s }
  kIf s=ifContinuationStmt kFi { fun(attr) { s(attr) } } |

  -- === While family ===
  -- while E do S od
  -- kWhile e=exp kDo s=stmt kOd { While (e, s) }
  loc=pos kWhile e=basic kDo s=exp kOd { fun(attr) { assertVoid(attr, While(e(Val), s(Void)), loc) } } |
  -- do S while E od
  -- kDo s=stmt kWhile e=exp kOd { DoWhile (s, e) }
  loc=pos kDo s=exp kWhile e=basic kOd { fun(attr) { assertVoid(attr, DoWhile(s(Void), e(Val)), loc) } } |

  -- additional extensions
  -- for s1, e, s2 do s3 od
  -- kFor s1=stmt s[","] e=exp s[","] s2=stmt kDo s3=stmt kOd {
  --   Seq (
  --     s1,
  --     While (e, Seq (s3, s2))
  --   )
  -- }
  loc=pos kFor s1=exp s[","] e=basic s[","] s2=exp kDo s3=exp kOd {
    fun(attr) {
      assertVoid(
        attr,
        Seq(
          s1(Void),
          While(e(Val), Seq (s3(Void), s2(Void)))
        ),
        loc
      )
    }
  }

  -- $(failure("the rest of primary parsing in not implemented\n"))
),
basic = memo $ eta (
  expr({
    [Right, {
      [s(":="), fun (l, loc, r) {
        fun (a) {assertValue(a, Assn(l(Ref), r(Val)), loc)}
      }]
    }],
    [Left, map(binop, {"!!"})],
    [Left, map(binop, {"&&"})],
    [Nona, map(binop, {"==", "!=", "<", ">", "<=", ">="})],
    [Left, map(binop, {"+", "-"})],
    [Left, map(binop, {"*", "/", "%"})]
  }, primary)
),
exp = memo $ eta syntax (
  basic |
  s1=basic s[";"] s2=exp { fun (a) {Seq(s1(Void), s2(a))} }
);


-- Public top-level parser
public parse = syntax (
  s=exp { s(Void) }
);